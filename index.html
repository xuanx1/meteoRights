<!DOCTYPE html>
<html lang="en">

<head>
  <style> 
    body { margin: 0; font-family: Arial, sans-serif; }
    
    /* ISS Toggle Button Styles */
    #iss-toggle-button {
      position: fixed;
      top: 20px;
      right: 20px;
      z-index: 1000;
      background: linear-gradient(135deg, #00BFFF, #0080FF);
      border: none;
      border-radius: 12px;
      padding: 12px 20px;
      color: white;
      font-weight: bold;
      font-size: 14px;
      cursor: pointer;
      box-shadow: 0 4px 15px rgba(0, 191, 255, 0.3);
      transition: all 0.3s ease;
      display: none; /* Hidden until ISS is loaded */
    }
    
    #iss-toggle-button:hover {
      background: linear-gradient(135deg, #0080FF, #0060FF);
      transform: translateY(-2px);
      box-shadow: 0 6px 20px rgba(0, 191, 255, 0.4);
    }
    
    #iss-toggle-button:active {
      transform: translateY(0);
      box-shadow: 0 3px 10px rgba(0, 191, 255, 0.3);
    }
    
    #iss-toggle-button .iss-icon {
      margin-right: 8px;
      font-size: 16px;
    }
    
    /* Legend styles - adapted from Leaflet control */
    .info.legend {
      position: fixed;
      bottom: 20px;
      right: 20px;
      z-index: 1000;
      background: rgba(255, 255, 255, 0);

      padding: 25px 30px;
      font-family: 'Open Sans', Arial, sans-serif;
      font-size: 12px;
      min-width: 280px;
      min-height: 180px;
      overflow: visible;
    }
    
    /* Astronaut Panel Styles */
    .astronaut-panels-container {
      position: fixed;
      bottom: 20px;
      left: 20px;
      z-index: 1000;
      display: flex;
      flex-direction: row;
      flex-wrap: nowrap;
      gap: 15px;
      align-items: flex-end;
      justify-content: flex-start;
    }
    
    .astronaut-panel {
      background: rgba(0, 0, 0, 0.8);
      border: 1px solid #ffffff;
      border-radius: 8px;
      padding: 15px 20px;
      font-family: 'Open Sans', Arial, sans-serif;
      color: white;
      width: 200px;
      min-width: 200px;
      max-width: 200px;
      box-shadow: 0 4px 12px rgba(255, 235, 59, 0.3);
      flex-shrink: 0;
    }
    
    .astronaut-panel h3 {
      margin: 0 0 10px 0;
      color: white;
      font-size: 16px;
      font-weight: bold;
      display: flex;
      align-items: center;
      gap: 8px;
    }
    
    .craft-icon {
      font-size: 18px;
    }
    
    .astronaut-count {
      font-size: 12px;
      margin-bottom: 12px;
      color: #00BFFF;
    }
    
    .astronaut-list {
      max-height: 150px;
      overflow-y: auto;
      scrollbar-width: thin;
      scrollbar-color: rgba(255, 255, 255, 0.3) transparent;
    }
    
    .astronaut-list::-webkit-scrollbar {
      width: 6px;
    }
    
    .astronaut-list::-webkit-scrollbar-track {
      background: transparent;
    }
    
    .astronaut-list::-webkit-scrollbar-thumb {
      background: rgba(255, 255, 255, 0.3);
      border-radius: 3px;
    }
    
    .astronaut-list::-webkit-scrollbar-thumb:hover {
      background: rgba(255, 255, 255, 0.5);
    }
    
    .astronaut-item {
      margin-bottom: 6px;
      padding: 6px 8px;
      background: rgba(255, 235, 59, 0.1);
      border-radius: 4px;
      border-left: 3px solid #ffeb3b;
    }
    
    .astronaut-name {
      font-weight: bold;
      color: white;
      font-size: 12px;
    }
  </style>

  <script src="https://cdn.jsdelivr.net/npm/globe.gl"></script>
  <!--<script src="../../dist/globe.gl.js"></script>-->
</head>

<body>
  <div id="globeViz"></div>
  
  <!-- ISS Toggle Button -->
  <button id="iss-toggle-button" onclick="toggleISSView()">
    <span class="iss-icon">üõ∞Ô∏è Zoom to ISS</span>
  </button>

  <!-- Legend adapted from Leaflet control -->
  <div class="info legend" id="magnitude-legend"></div>

  <!-- Astronaut Panels Container -->
  <div class="astronaut-panels-container" id="astronaut-panels-container" style="display: none;">
    <!-- Panels will be dynamically created here -->
  </div>

  <script type="module">
    import * as THREE from 'https://esm.sh/three';
    import { loadMeteoriteAndFireballData, setAddFireballMarkersToGlobe, setAddMeteoriteMarkersToGlobe, setAddISSToGlobe, setAddAstronautPanelToPage } from './js/globe.js';

    // Utility functions for hover display
    function formatScientificNotation(value) {
      if (!value || value === '') return 'Unknown';
      const num = parseFloat(value);
      if (isNaN(num)) return value;
      return num.toExponential(2).replace('e+', ' √ó 10^').replace('e-', ' √ó 10^-');
    }

    function formatNumber(value) {
      if (!value || value === '') return 'Unknown';
      const num = parseFloat(value);
      if (isNaN(num)) return value;
      return num.toLocaleString();
    }

    // Enhanced location lookup with multiple fallback APIs
    async function getLocationName(lat, lng) {
      // Try multiple geocoding services for better success rate
      const geocodingServices = [
        // Service 1: BigDataCloud (free, no key required)
        async () => {
          const controller = new AbortController();
          const timeoutId = setTimeout(() => controller.abort(), 5000);
          
          const response = await fetch(`https://api.bigdatacloud.net/data/reverse-geocode-client?latitude=${lat}&longitude=${lng}&localityLanguage=en`, {
            signal: controller.signal
          });
          clearTimeout(timeoutId);
          
          if (!response.ok) throw new Error(`BigDataCloud HTTP ${response.status}`);
          
          const data = await response.json();
          console.log('BigDataCloud data for', lat, lng, ':', data);
          
          if (data.city && data.countryName) {
            return `Near ${data.city}, ${data.countryName}`;
          } else if (data.locality && data.countryName) {
            return `Near ${data.locality}, ${data.countryName}`;
          } else if (data.principalSubdivision && data.countryName) {
            return `Near ${data.principalSubdivision}, ${data.countryName}`;
          } else if (data.countryName) {
            return `${data.countryName}`;
          }
          throw new Error('No usable location data from BigDataCloud');
        },
        
        // Service 2: OpenStreetMap Nominatim (free, no key required)
        async () => {
          const controller = new AbortController();
          const timeoutId = setTimeout(() => controller.abort(), 5000);
          
          const response = await fetch(`https://nominatim.openstreetmap.org/reverse?format=json&lat=${lat}&lon=${lng}&addressdetails=1&accept-language=en`, {
            signal: controller.signal,
            headers: {
              'User-Agent': 'MeteoRights/1.0 (Fireball Visualization)'
            }
          });
          clearTimeout(timeoutId);
          
          if (!response.ok) throw new Error(`Nominatim HTTP ${response.status}`);
          
          const data = await response.json();
          console.log('Nominatim data for', lat, lng, ':', data);
          
          if (data.address) {
            const addr = data.address;
            const city = addr.city || addr.town || addr.village || addr.municipality;
            const country = addr.country;
            
            if (city && country) {
              return `Near ${city}, ${country}`;
            } else if (addr.state && country) {
              return `Near ${addr.state}, ${country}`;
            } else if (country) {
              return `${country}`;
            }
          }
          throw new Error('No usable location data from Nominatim');
        },
        
        // Service 3: Geographic classifier (backup with country/ocean detection)
        async () => {
          // Skip the API call and go directly to geographic classification
          
          // Country/region boundaries (approximate)
          const countries = [
            { name: "United States", latRange: [25, 50], lngRange: [-125, -65] },
            { name: "Canada", latRange: [42, 85], lngRange: [-141, -52] },
            { name: "Mexico", latRange: [14, 33], lngRange: [-118, -86] },
            { name: "Brazil", latRange: [-34, 5], lngRange: [-74, -35] },
            { name: "Argentina", latRange: [-55, -22], lngRange: [-73, -53] },
            { name: "Russia", latRange: [41, 82], lngRange: [19, 180] },
            { name: "Russia", latRange: [64, 82], lngRange: [-180, -169] },
            { name: "China", latRange: [18, 54], lngRange: [73, 135] },
            { name: "India", latRange: [6, 37], lngRange: [68, 97] },
            { name: "Australia", latRange: [-44, -10], lngRange: [113, 154] },
            { name: "South Africa", latRange: [-35, -22], lngRange: [16, 33] },
            { name: "Algeria", latRange: [19, 37], lngRange: [-8, 12] },
            { name: "Saudi Arabia", latRange: [16, 32], lngRange: [34, 55] },
            { name: "Kazakhstan", latRange: [40, 56], lngRange: [46, 87] },
            { name: "Iran", latRange: [25, 40], lngRange: [44, 63] },
            { name: "Libya", latRange: [20, 33], lngRange: [9, 25] },
            { name: "Sudan", latRange: [8, 22], lngRange: [21, 39] },
            { name: "Chad", latRange: [7, 23], lngRange: [13, 24] },
            { name: "Niger", latRange: [11, 24], lngRange: [0, 16] },
            { name: "Angola", latRange: [-18, -4], lngRange: [11, 24] },
            { name: "Mali", latRange: [10, 25], lngRange: [-12, 4] },
            { name: "Ethiopia", latRange: [3, 18], lngRange: [33, 48] },
            { name: "Egypt", latRange: [22, 32], lngRange: [25, 37] },
            { name: "Tanzania", latRange: [-12, -1], lngRange: [29, 41] },
            { name: "Nigeria", latRange: [4, 14], lngRange: [2, 15] },
            { name: "Venezuela", latRange: [0, 12], lngRange: [-73, -60] },
            { name: "Colombia", latRange: [-4, 12], lngRange: [-79, -66] },
            { name: "Peru", latRange: [-18, 0], lngRange: [-81, -68] },
            { name: "Mongolia", latRange: [41, 52], lngRange: [87, 120] }
          ];
          
          // Check if coordinates fall within any country
          for (const country of countries) {
            if (lat >= country.latRange[0] && lat <= country.latRange[1] &&
                lng >= country.lngRange[0] && lng <= country.lngRange[1]) {
              return `Near ${country.name}`;
            }
          }
          
          // Ocean classification
          const oceans = [
            { name: "Pacific Ocean", latRange: [-60, 65], lngRange: [120, -70] }, // Crosses dateline
            { name: "Atlantic Ocean", latRange: [-60, 70], lngRange: [-70, 20] },
            { name: "Indian Ocean", latRange: [-60, 30], lngRange: [20, 120] },
            { name: "Arctic Ocean", latRange: [65, 90], lngRange: [-180, 180] },
            { name: "Southern Ocean", latRange: [-90, -60], lngRange: [-180, 180] }
          ];
          
          // Special handling for Pacific Ocean (crosses dateline)
          if (lat >= -60 && lat <= 65 && (lng >= 120 || lng <= -70)) {
            return "Pacific Ocean";
          }
          
          // Check other oceans
          for (const ocean of oceans) {
            if (ocean.name !== "Pacific Ocean" && 
                lat >= ocean.latRange[0] && lat <= ocean.latRange[1] &&
                lng >= ocean.lngRange[0] && lng <= ocean.lngRange[1]) {
              return ocean.name;
            }
          }
          
          // Default fallback
          return "Remote Location";
        }
      ];
      
      // Try each service in sequence until one succeeds
      for (let i = 0; i < geocodingServices.length; i++) {
        try {
          console.log(`Trying geocoding service ${i + 1} for`, lat, lng);
          const result = await geocodingServices[i]();
          console.log(`Service ${i + 1} succeeded:`, result);
          return result;
        } catch (error) {
          console.warn(`Geocoding service ${i + 1} failed for`, lat, lng, ':', error.message);
          
          // If this is the last service, provide a meaningful fallback
          if (i === geocodingServices.length - 1) {
            // Simple country/ocean classification based on major regions
            if (lat >= 25 && lat <= 50 && lng >= -125 && lng <= -65) {
              return "Near United States";
            } else if (lat >= 42 && lat <= 85 && lng >= -141 && lng <= -52) {
              return "Near Canada";
            } else if (lat >= 18 && lat <= 54 && lng >= 73 && lng <= 135) {
              return "Near China";
            } else if (lat >= 41 && lat <= 82 && lng >= 19 && lng <= 180) {
              return "Near Russia";
            } else if (lat >= -44 && lat <= -10 && lng >= 113 && lng <= 154) {
              return "Near Australia";
            } else if (lat >= -60 && lat <= 65 && (lng >= 120 || lng <= -70)) {
              return "Pacific Ocean";
            } else if (lat >= -60 && lat <= 70 && lng >= -70 && lng <= 20) {
              return "Atlantic Ocean";
            } else if (lat >= -60 && lat <= 30 && lng >= 20 && lng <= 120) {
              return "Indian Ocean";
            } else if (lat >= 65) {
              return "Arctic Ocean";
            } else if (lat <= -60) {
              return "Southern Ocean";
            } else {
              return "Remote Location";
            }
          }
        }
      }
    }

    // Create hover tooltip
    function createTooltip() {
      const tooltip = document.createElement('div');
      tooltip.id = 'fireball-tooltip';
      tooltip.style.cssText = `
        position: absolute;
        background: rgba(0, 0, 0, 0.9);
        color: #ffeb3b;
        padding: 12px;
        border-radius: 8px;
        font-family: Arial, sans-serif;
        font-size: 12px;
        line-height: 1.4;
        pointer-events: none;
        z-index: 1000;
        border: 1px solid #ffeb3b;
        box-shadow: 0 4px 12px rgba(255, 235, 59, 0.3);
        max-width: 300px;
        display: none;
      `;
      document.body.appendChild(tooltip);
      return tooltip;
    }

    const tooltip = createTooltip();

    // Add title
    const titleContainer = document.createElement("div");
    titleContainer.style.position = "absolute";
    titleContainer.style.top = "20px";
    titleContainer.style.left = "20px";
    titleContainer.style.zIndex = "1000";
    titleContainer.style.color = "white";
    titleContainer.style.fontFamily = '"Inter", sans-serif';
    titleContainer.style.pointerEvents = "none";

    const mainTitle = document.createElement("h1");
    mainTitle.innerHTML = "All Fireballs <br> and Meteorites<br> Ever Recorded,<br> Mapped";
    mainTitle.style.margin = "-5px 0 0 0";
    mainTitle.style.fontSize = "56px";
    mainTitle.style.lineHeight = "1.2";
    mainTitle.style.color = "white";

    const subTitle = document.createElement("p");
    subTitle.textContent = "and the ISS too.";
    subTitle.style.margin = "5px 0 0 0";
    subTitle.style.fontSize = "18.5px";
    subTitle.style.color = "#fed86b";
    subTitle.style.opacity = "0.9";

    titleContainer.appendChild(mainTitle);
    titleContainer.appendChild(subTitle);
    document.body.appendChild(titleContainer);

    const world = new Globe(document.getElementById('globeViz'), { animateIn: false })
      .globeImageUrl('https://cdn.jsdelivr.net/npm/three-globe/example/img/earth-blue-marble.jpg')
      .bumpImageUrl('https://cdn.jsdelivr.net/npm/three-globe/example/img/earth-topology.png');

    // Auto-rotate
    world.controls().autoRotate = true;
    world.controls().autoRotateSpeed = 0.35;

    // Global variable to track ISS view state
    let isISSView = false;

    // Global function to toggle between ISS view and Earth view
    window.toggleISSView = function() {
      const toggleButton = document.getElementById('iss-toggle-button');
      
      if (!isISSView) {
        // Zoom to ISS
        if (issObject && issObject.mesh) {
          console.log('üõ∞Ô∏è Starting ISS zoom and tracking...');
          console.log('üõ∞Ô∏è ISS object found:', issObject);
          console.log('üõ∞Ô∏è ISS mesh position:', issObject.mesh.position);
          console.log('üõ∞Ô∏è Original ISS coordinates:', issObject.originalLat, issObject.originalLng);
          
          // Enable ISS tracking mode
          issObject.isTracking = true;
          
          // Stop auto-rotation while tracking ISS
          world.controls().autoRotate = false;
          
          // Use the ORIGINAL ISS coordinates for initial zoom
          console.log('üõ∞Ô∏è Zooming to ORIGINAL ISS coordinates:', issObject.originalLat, issObject.originalLng);
          
          // Zoom directly to original ISS coordinates
          world.pointOfView({
            lat: issObject.originalLat,
            lng: issObject.originalLng,
            altitude: 0.8 // Good distance to see the detailed ISS model
          }, 2000); // 2 second transition
          
          // Update button text and state
          isISSView = true;
          toggleButton.innerHTML = '<span class="iss-icon">üåç</span>Zoom Out to Earth';
          
          // Fade out titles when zooming to ISS
          const titleContainer = document.querySelector("div[style*='position: absolute'][style*='top: 20px'][style*='left: 20px']");
          if (titleContainer) {
            titleContainer.style.transition = 'opacity 1.5s ease';
            titleContainer.style.opacity = '0';
          }
          
          console.log('‚úÖ Zoomed to ISS coordinates and ENABLED tracking - camera will follow ISS station');
        } else {
          console.warn('‚ö†Ô∏è ISS not available for tracking');
          console.log('Debug: issObject =', issObject);
          alert('ISS not found! Check console for debugging info.');
        }
      } else {
        // Zoom out to Earth
        console.log('üåç Stopping ISS tracking and resetting to default view...');
        
        // DISABLE ISS tracking mode
        if (issObject) {
          issObject.isTracking = false;
          console.log('üõ∞Ô∏è ISS tracking mode DISABLED');
        }
        
        // Reset to default global view
        world.pointOfView({
          lat: 0,
          lng: 0,
          altitude: 2.0 // Higher altitude = zoomed out view of whole Earth
        }, 1500); // 1.5 second transition
        
        // Update button text and state
        isISSView = false;
        toggleButton.innerHTML = '<span class="iss-icon">üõ∞Ô∏è</span>Zoom to ISS';
        
        // Fade in titles when zooming out to Earth
        const titleContainer = document.querySelector("div[style*='position: absolute'][style*='top: 20px'][style*='left: 20px']");
        if (titleContainer) {
          titleContainer.style.transition = 'opacity 1.5s ease';
          titleContainer.style.opacity = '1';
        }
        
        // Reset auto-rotation speed
        setTimeout(() => {
          world.controls().autoRotate = true;
          world.controls().autoRotateSpeed = 0.35; // Default rotation speed
        }, 1800);
        
        console.log('‚úÖ Reset to global view - camera no longer follows ISS station');
      }
    };

    // Raycaster for hover detection
    const raycaster = new THREE.Raycaster();
    const mouse = new THREE.Vector2();
    let fireballSpheres = []; // Store references to fireball spheres with their data
    let meteoriteSpheres = []; // Store references to meteorite spheres with their data
    let issObject = null; // Store ISS object reference

    // Mouse move handler for hover
    function onMouseMove(event) {
      mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
      mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;

      raycaster.setFromCamera(mouse, world.camera());
      
      // Check for fireball intersections
      const fireballIntersects = raycaster.intersectObjects(fireballSpheres.map(f => f.sphere));
      
      // Check for meteorite intersections
      const meteoriteIntersects = raycaster.intersectObjects(meteoriteSpheres.map(m => m.sphere));
      
      // Check for ISS intersection
      let issIntersects = [];
      if (issObject) {
        issIntersects = raycaster.intersectObject(issObject.mesh);
      }

      if (fireballIntersects.length > 0) {
        const intersectedFireball = fireballSpheres.find(f => f.sphere === fireballIntersects[0].object);
        if (intersectedFireball) {
          showFireballTooltip(event, intersectedFireball.data);
        }
      } else if (meteoriteIntersects.length > 0) {
        const intersectedMeteorite = meteoriteSpheres.find(m => m.sphere === meteoriteIntersects[0].object);
        if (intersectedMeteorite) {
          showMeteoriteTooltip(event, intersectedMeteorite.data);
        }
      } else if (issIntersects.length > 0) {
        showISSTooltip(event, issObject.data);
      } else {
        hideTooltip();
      }
    }

    // Show tooltip with fireball information
    async function showFireballTooltip(event, fireballData) {
      // Show tooltip immediately with coordinates, then update with location
      tooltip.innerHTML = `
        <div style="color: #ffeb3b; font-weight: bold; margin-bottom: 8px;">üî• Fireball Event</div>
        <div><span style="color: white;">Location:</span> <span style="color: #ffeb3b;">Loading...</span></div>
        <div><span style="color: white;">Date/Time:</span> <span style="color: #ffeb3b;">${fireballData.date || 'Unknown'}</span></div>
        <div><span style="color: white;">Energy:</span> <span style="color: #ffeb3b;">${formatScientificNotation(fireballData.energy)} J</span></div>
        <div><span style="color: white;">Velocity:</span> <span style="color: #ffeb3b;">${formatNumber(fireballData.velocity)} km/s</span></div>
        <div><span style="color: white;">Altitude:</span> <span style="color: #ffeb3b;">${formatNumber(fireballData.altitude)} km</span></div>
        <div style="margin-top: 6px; font-size: 11px; color: #ccc;">
          Coordinates: ${fireballData.lat.toFixed(4)}¬∞, ${fireballData.lng.toFixed(4)}¬∞
        </div>
      `;
      
      tooltip.style.display = 'block';
      tooltip.style.left = (event.clientX + 10) + 'px';
      tooltip.style.top = (event.clientY - 10) + 'px';
      
      // Try to get location name and update tooltip
      try {
        const locationName = await getLocationName(fireballData.lat, fireballData.lng);
        
        // Only update if tooltip is still visible
        if (tooltip.style.display === 'block') {
          tooltip.innerHTML = `
            <div style="color: #ffeb3b; font-weight: bold; margin-bottom: 8px;">üî• Fireball Event</div>
            <div><span style="color: white;">Location:</span> <span style="color: #ffeb3b;">${locationName}</span></div>
            <div><span style="color: white;">Date/Time:</span> <span style="color: #ffeb3b;">${fireballData.date || 'Unknown'}</span></div>
            <div><span style="color: white;">Energy:</span> <span style="color: #ffeb3b;">${formatScientificNotation(fireballData.energy)} J</span></div>
            <div><span style="color: white;">Velocity:</span> <span style="color: #ffeb3b;">${formatNumber(fireballData.velocity)} km/s</span></div>
            <div><span style="color: white;">Altitude:</span> <span style="color: #ffeb3b;">${formatNumber(fireballData.altitude)} km</span></div>
            <div style="margin-top: 6px; font-size: 11px; color: #ccc;">
              Coordinates: ${fireballData.lat.toFixed(4)}¬∞, ${fireballData.lng.toFixed(4)}¬∞
            </div>
          `;
        }
      } catch (error) {
        console.warn('Failed to update location in tooltip:', error);
      }
    }

    // Show tooltip with meteorite information
    async function showMeteoriteTooltip(event, meteoriteData) {
      // Show tooltip immediately with meteorite info
      const mass = parseFloat(meteoriteData.mass) || 0;
      const massDisplay = mass > 0 ? `${mass.toLocaleString()} g` : 'Unknown';
      const year = parseInt(meteoriteData.year) || null;
      const ageDisplay = year ? `${2025 - year} years old` : 'Unknown age';
      
      tooltip.innerHTML = `
        <div style="color: #FF00FF; font-weight: bold; margin-bottom: 8px;">‚òÑÔ∏è Meteorite Landing</div>
        <div><span style="color: white;">Name:</span> <span style="color: #FF00FF;">${meteoriteData.name || 'Unknown'}</span></div>
        <div><span style="color: white;">Location:</span> <span style="color: #FF00FF;">Loading...</span></div>
        <div><span style="color: white;">Mass:</span> <span style="color: #FF00FF;">${massDisplay}</span></div>
        <div><span style="color: white;">Year Found:</span> <span style="color: #FF00FF;">${meteoriteData.year || 'Unknown'}</span></div>
        <div><span style="color: white;">Age:</span> <span style="color: #FF00FF;">${ageDisplay}</span></div>
        <div><span style="color: white;">Classification:</span> <span style="color: #FF00FF;">${meteoriteData.recclass || 'Unknown'}</span></div>
        <div style="margin-top: 6px; font-size: 11px; color: #ccc;">
          Coordinates: ${meteoriteData.lat.toFixed(4)}¬∞, ${meteoriteData.lng.toFixed(4)}¬∞
        </div>
      `;
      
      tooltip.style.display = 'block';
      tooltip.style.left = (event.clientX + 10) + 'px';
      tooltip.style.top = (event.clientY - 10) + 'px';
      
      // Try to get location name and update tooltip
      try {
        const locationName = await getLocationName(meteoriteData.lat, meteoriteData.lng);
        
        // Only update if tooltip is still visible
        if (tooltip.style.display === 'block') {
          tooltip.innerHTML = `
            <div style="color: #FF00FF; font-weight: bold; margin-bottom: 8px;">‚òÑÔ∏è Meteorite Landing</div>
            <div><span style="color: white;">Name:</span> <span style="color: #FF00FF;">${meteoriteData.name || 'Unknown'}</span></div>
            <div><span style="color: white;">Location:</span> <span style="color: #FF00FF;">${locationName}</span></div>
            <div><span style="color: white;">Mass:</span> <span style="color: #FF00FF;">${massDisplay}</span></div>
            <div><span style="color: white;">Year Found:</span> <span style="color: #FF00FF;">${meteoriteData.year || 'Unknown'}</span></div>
            <div><span style="color: white;">Age:</span> <span style="color: #FF00FF;">${ageDisplay}</span></div>
            <div><span style="color: white;">Classification:</span> <span style="color: #FF00FF;">${meteoriteData.recclass || 'Unknown'}</span></div>
            <div style="margin-top: 6px; font-size: 11px; color: #ccc;">
              Coordinates: ${meteoriteData.lat.toFixed(4)}¬∞, ${meteoriteData.lng.toFixed(4)}¬∞
            </div>
          `;
        }
      } catch (error) {
        console.warn('Failed to update location in meteorite tooltip:', error);
      }
    }

    // Show tooltip with ISS information
    async function showISSTooltip(event, issData) {
      //const currentTime = new Date().toLocaleString();
      const speed = 27600; // ISS orbital speed in km/h
      const orbitTime = 93; // ISS orbit time in minutes
      
      tooltip.innerHTML = `
        <div style="color: #00BFFF; font-weight: bold; margin-bottom: 8px;">üõ∞Ô∏è International Space Station</div>
        <div><span style="color: white;">Location:</span> <span style="color: #00BFFF;">Loading...</span></div>
        <div><span style="color: white;">Altitude:</span> <span style="color: #00BFFF;">${issData.altitude} km</span></div>
        <div><span style="color: white;">Orbital Speed:</span> <span style="color: #00BFFF;">${speed.toLocaleString()} km/h</span></div>
        <div><span style="color: white;">Orbit Period:</span> <span style="color: #00BFFF;">${orbitTime} minutes</span></div>

        <div style="margin-top: 6px; font-size: 11px; color: #ccc;">
          Coordinates: ${issData.lat.toFixed(4)}¬∞, ${issData.lng.toFixed(4)}¬∞
        </div>
      `;
      
      tooltip.style.display = 'block';
      tooltip.style.left = (event.clientX + 10) + 'px';
      tooltip.style.top = (event.clientY - 10) + 'px';
      
      // Try to get location name and update tooltip
      try {
        const locationName = await getLocationName(issData.lat, issData.lng);
        
        // Only update if tooltip is still visible
        if (tooltip.style.display === 'block') {
          tooltip.innerHTML = `
            <div style="color: #00BFFF; font-weight: bold; margin-bottom: 8px;">üõ∞Ô∏è International Space Station</div>
            <div><span style="color: white;">Over:</span> <span style="color: #00BFFF;">${locationName}</span></div>
            <div><span style="color: white;">Altitude:</span> <span style="color: #00BFFF;">${issData.altitude} km</span></div>
            <div><span style="color: white;">Orbital Speed:</span> <span style="color: #00BFFF;">${speed.toLocaleString()} km/h</span></div>
            <div><span style="color: white;">Orbit Period:</span> <span style="color: #00BFFF;">${orbitTime} minutes</span></div>

            <div style="margin-top: 6px; font-size: 11px; color: #ccc;">
              Coordinates: ${issData.lat.toFixed(4)}¬∞, ${issData.lng.toFixed(4)}¬∞
            </div>
          `;
        }
      } catch (error) {
        console.warn('Failed to update location in ISS tooltip:', error);
      }
    }

    // Hide tooltip
    function hideTooltip() {
      tooltip.style.display = 'none';
    }

    // Add event listeners
    document.addEventListener('mousemove', onMouseMove);
    document.addEventListener('mouseleave', hideTooltip);

    // Set up callback to add fireball markers to the globe
    setAddFireballMarkersToGlobe((fireballMarkers) => {
      console.log('Adding', fireballMarkers.length, 'fireballs to globe');
      
      // Remove the problematic labels approach and use only 3D objects
      setTimeout(() => {
        // Debug: Show first few fireball coordinates and check for known locations
        console.log('First 10 fireball coordinates:');
        fireballMarkers.slice(0, 10).forEach((fb, i) => {
          console.log(`  ${i}: lat=${fb.lat}, lng=${fb.lng}, alt=${fb.altitude}km`);
          
          // Check if any are in known regions for verification
          if (fb.lat >= 6 && fb.lat <= 37 && fb.lng >= 68 && fb.lng <= 97) {
            console.log(`    ‚Ü≥ This should be in India region`);
          } else if (fb.lat >= 25 && fb.lat <= 50 && fb.lng >= -125 && fb.lng <= -65) {
            console.log(`    ‚Ü≥ This should be in USA region`);
          } else if (fb.lat >= 18 && fb.lat <= 54 && fb.lng >= 73 && fb.lng <= 135) {
            console.log(`    ‚Ü≥ This should be in China region`);
          }
        });
        
        fireballMarkers.forEach((fb, index) => {
          console.log(`Processing fireball ${index}: lat=${fb.lat}, lng=${fb.lng}`);
          
          // Use Globe.gl's built-in coordinate conversion
          const altitudeKm = parseFloat(fb.altitude) || 0;
          console.log('Fireball position: lat', fb.lat, 'lng', fb.lng, 'alt', altitudeKm, 'km');
          
          // Much smaller altitude scaling to keep fireballs close to surface
          const scaledAltitude = altitudeKm / 1000; // Very small scaling - divide by 1000 instead of 20
          
          // Use Globe.gl's getCoords method for proper coordinate conversion
          const coords = world.getCoords(fb.lat, fb.lng, Math.max(0.01, scaledAltitude));
          const { x, y, z } = coords;
          
          console.log(`3D position for lat=${fb.lat}, lng=${fb.lng}: x=${x.toFixed(2)}, y=${y.toFixed(2)}, z=${z.toFixed(2)}`);
          
          // Create glowing sphere with same size for all fireballs
          const sphereSize = 0.6; // Fixed size regardless of altitude
          const geometry = new THREE.SphereGeometry(sphereSize, 16, 16);
          const material = new THREE.MeshBasicMaterial({
            color: 0xff6600, // All orange color
            transparent: true,
            opacity: 0.9,
            blending: THREE.AdditiveBlending // Blend with illumination
          });
          const sphere = new THREE.Mesh(geometry, material);
          sphere.position.set(x, y, z);
          
          // Create illumination circles (multiple circles for glow effect like lamp posts)
          const energy = parseFloat(fb.energy) || 0;
          console.log('Raw energy value:', fb.energy, 'Parsed:', energy);
          
          // Better normalization for scientific notation energy values
          // Energy ranges from about 1e6 J to 1e15 J based on typical fireball data
          const logEnergy = energy > 0 ? Math.log10(energy) : 6; // Default to 1e6 if no energy
          const normalizedEnergy = Math.max(0, Math.min(1, (logEnergy - 6) / 9)); // Map 1e6-1e15 to 0-1
          const energyIntensity = Math.max(0.1, normalizedEnergy); // Minimum 0.1 intensity
          
          console.log('Energy calculation:', {
            rawEnergy: energy,
            logEnergy: logEnergy,
            normalizedEnergy: normalizedEnergy,
            energyIntensity: energyIntensity
          });
          
          const baseRadius = 0.8 + (energyIntensity * 1.5); // Radius varies from 0.8 to 2.3
          const illuminationColor = 0xffff00; // Yellow illumination
          const baseIntensity = 0.4 + (energyIntensity * 0.8); // Intensity varies from 0.4 to 1.2
          
          // Main illumination circle (filled, not ring)
          const illuminationGeometry = new THREE.CircleGeometry(baseRadius, 32);
          const illuminationMaterial = new THREE.MeshBasicMaterial({
            color: illuminationColor,
            transparent: true,
            opacity: baseIntensity * 0.3, // Base illumination opacity
            side: THREE.DoubleSide,
            depthWrite: false, // Prevent z-fighting
            blending: THREE.AdditiveBlending // Better blending for overlapping
          });
          const illuminationCircle = new THREE.Mesh(illuminationGeometry, illuminationMaterial);
          
          // Position slightly offset from surface to prevent glitching
          const normal = new THREE.Vector3(x, y, z).normalize();
          const offsetDistance = 0.01; // Small offset from surface
          illuminationCircle.position.set(
            x + normal.x * offsetDistance,
            y + normal.y * offsetDistance, 
            z + normal.z * offsetDistance
          );
          illuminationCircle.lookAt(0, 0, 0); // Face the center of the globe
          
          console.log('Energy for fireball at', fb.lat, fb.lng, ':', energy, 'J (', energy.toExponential(2), '), illumination intensity:', energyIntensity, 'radius:', baseRadius.toFixed(2));
          
          // Add glow effect with multiple circles (like the lamp post code)
          const glowCircles = [];
          for (let i = 1; i <= 3; i++) {
            const glowRadius = baseRadius + (i * 0.3);
            const glowGeometry = new THREE.CircleGeometry(glowRadius, 32);
            const glowMaterial = new THREE.MeshBasicMaterial({
              color: illuminationColor,
              transparent: true,
              opacity: (baseIntensity * 0.2) / i, // Decreasing opacity for outer glow
              side: THREE.DoubleSide,
              depthWrite: false, // Prevent z-fighting
              blending: THREE.AdditiveBlending // Better blending for overlapping
            });
            const glowCircle = new THREE.Mesh(glowGeometry, glowMaterial);
            
            // Position each glow circle at slightly different distances to prevent overlap
            const glowOffset = offsetDistance + (i * 0.005);
            glowCircle.position.set(
              x + normal.x * glowOffset,
              y + normal.y * glowOffset,
              z + normal.z * glowOffset
            );
            glowCircle.lookAt(0, 0, 0); // Face the center of the globe
            glowCircles.push(glowCircle);
          }
          
          // Create orbiting light
          const orbitGeometry = new THREE.SphereGeometry(0.2, 8, 8);
          const orbitMaterial = new THREE.MeshBasicMaterial({
            color: 0xffaa44,
            transparent: true,
            opacity: 0.8
          });
          const orbitSphere = new THREE.Mesh(orbitGeometry, orbitMaterial);
          
          // Add all objects to scene (illumination circles first, then sphere)
          world.scene().add(illuminationCircle);
          glowCircles.forEach(circle => world.scene().add(circle));
          world.scene().add(sphere);
          world.scene().add(orbitSphere);

          // Store fireball reference for hover detection
          fireballSpheres.push({
            sphere: sphere,
            data: fb
          });
          
          // Animate the illumination pulsing (like Singapore lamp posts)
          let pulseTime = index * 0.5; // Offset each fireball's pulse
          let glideTime = index * 1.2; // Offset each fireball's glide animation
          
          // Calculate glide speed based on velocity from CSV data
          const velocity = parseFloat(fb.velocity) || 20; // Default 20 km/s if no velocity data
          console.log('Velocity for fireball at', fb.lat, fb.lng, ':', velocity, 'km/s');
          
          // Normalize velocity (typical range 11-72 km/s for meteors)
          const normalizedVelocity = Math.max(0.1, Math.min(1, (velocity - 11) / 61)); // Map 11-72 km/s to 0.1-1
          const velocityBasedSpeed = 0.008 + (normalizedVelocity * 0.025); // Speed varies from 0.008 to 0.033
          
          // Higher velocity = more oscillation and faster movement
          const velocityOscillation = 0.1 + (normalizedVelocity * 0.3); // Restored to the working version: 0.1 to 0.4
          const glideDuration = 12 - (normalizedVelocity * 6); // Duration from 12s (slow) to 6s (fast)
          
          console.log('Velocity calculations:', {
            velocity: velocity,
            normalizedVelocity: normalizedVelocity,
            glideSpeed: velocityBasedSpeed,
            oscillation: velocityOscillation,
            duration: glideDuration
          });
          
          // Store original position for gliding calculation
          const originalLat = fb.lat;
          const originalLng = fb.lng;
          const originalAltitude = Math.max(0.01, scaledAltitude);
          
          const animateIllumination = () => {
            pulseTime += 0.02;
            glideTime += velocityBasedSpeed; // Use velocity-based speed instead of fixed speed
            
            // Create pulsing effect like the lamp post CSS animation
            const pulseScale = 1 + 0.2 * Math.sin(pulseTime * 2); // Scale between 0.8 and 1.2
            const pulseOpacity = 0.8 + 0.4 * Math.sin(pulseTime * 2); // Opacity variation
            
            // Shooting star gliding animation
            const glideProgress = (glideTime % glideDuration) / glideDuration; // 0 to 1
            const glidePhase = glideProgress * Math.PI * 2; // Full circle
            
            // Calculate gliding position - oscillation based on velocity
            const glideLat = originalLat + (Math.sin(glidePhase) * velocityOscillation * 10); // Restored to 10x multiplier
            const glideLng = originalLng + (Math.cos(glidePhase) * velocityOscillation * 10); // Restored to 10x multiplier
            
            // Debug gliding for first fireball
            if (index === 0 && Math.floor(glideTime) % 3 === 0) {
              console.log(`Gliding debug - Fireball ${index}:`, {
                glideTime: glideTime.toFixed(2),
                glideProgress: glideProgress.toFixed(3),
                glidePhase: glidePhase.toFixed(3),
                originalLat: originalLat,
                originalLng: originalLng,
                glideLat: glideLat.toFixed(4),
                glideLng: glideLng.toFixed(4),
                latOffset: (glideLat - originalLat).toFixed(4),
                lngOffset: (glideLng - originalLng).toFixed(4),
                oscillation: velocityOscillation,
                speed: velocityBasedSpeed,
                sinValue: Math.sin(glidePhase).toFixed(4),
                cosValue: Math.cos(glidePhase).toFixed(4)
              });
            }
            
            // Use Globe.gl's coordinate conversion for gliding position
            const glideCoords = world.getCoords(glideLat, glideLng, originalAltitude);
            const { x: glideX, y: glideY, z: glideZ } = glideCoords;
            
            // Fade in/out effect for shooting star
            let starOpacity = 1;
            if (glideProgress < 0.1) {
              starOpacity = glideProgress / 0.1; // Fade in
            } else if (glideProgress > 0.9) {
              starOpacity = (1 - glideProgress) / 0.1; // Fade out
            }
            
            // Update fireball position
            sphere.position.set(glideX, glideY, glideZ);
            
            // Update illumination positions
            const glideNormal = new THREE.Vector3(glideX, glideY, glideZ).normalize();
            const offsetDistance = 0.01; // Small offset from surface
            illuminationCircle.position.set(
              glideX + glideNormal.x * offsetDistance,
              glideY + glideNormal.y * offsetDistance,
              glideZ + glideNormal.z * offsetDistance
            );
            illuminationCircle.lookAt(0, 0, 0);
            
            // Update glow circles positions
            glowCircles.forEach((circle, i) => {
              const glowOffset = offsetDistance + (i * 0.005);
              circle.position.set(
                glideX + glideNormal.x * glowOffset,
                glideY + glideNormal.y * glowOffset,
                glideZ + glideNormal.z * glowOffset
              );
              circle.lookAt(0, 0, 0);
            });
            
            // Animate the fireball sphere with pulsing and color blending
            const fireballPulse = 1 + 0.1 * Math.sin(pulseTime * 2.5); // Reduced pulse from 0.3 to 0.1
            const fireballOpacity = 0.85 + 0.15 * Math.sin(pulseTime * 2.5); // Reduced opacity variation
            
            // Blend orange with yellow based on energy and pulse
            const blendFactor = 0.3 + (energyIntensity * 0.4) + (0.1 * Math.sin(pulseTime * 3)); // Reduced color pulse
            const blendedColor = new THREE.Color(0xff6600).lerp(new THREE.Color(0xffff00), blendFactor);
            
            sphere.scale.setScalar(fireballPulse);
            sphere.material.opacity = 0.9 * fireballOpacity * starOpacity;
            sphere.material.color = blendedColor;
            
            // Apply pulsing to main illumination circle
            illuminationCircle.scale.setScalar(pulseScale);
            illuminationCircle.material.opacity = (baseIntensity * 0.3) * pulseOpacity * starOpacity;
            
            // Apply pulsing to glow circles with different phases
            glowCircles.forEach((circle, i) => {
              const phaseOffset = i * 0.5;
              const glowPulse = 1 + 0.15 * Math.sin((pulseTime + phaseOffset) * 1.5);
              const glowOpacityPulse = 0.7 + 0.3 * Math.sin((pulseTime + phaseOffset) * 1.5);
              
              circle.scale.setScalar(glowPulse);
              circle.material.opacity = ((baseIntensity * 0.2) / (i + 1)) * glowOpacityPulse * starOpacity;
            });
            
            requestAnimationFrame(animateIllumination);
          };
          
          animateIllumination();
          
          // Animate the orbiting sphere to follow the gliding fireball
          let angle = index * Math.PI / 4;
          const animate = () => {
            angle += 0.02;
            const orbitRadius = 1.5;
            
            // Get current fireball position for orbiting
            const currentFireballPos = sphere.position;
            const orbitX = currentFireballPos.x + orbitRadius * Math.cos(angle);
            const orbitZ = currentFireballPos.z + orbitRadius * Math.sin(angle);
            
            orbitSphere.position.set(orbitX, currentFireballPos.y, orbitZ);
            requestAnimationFrame(animate);
          };
          
          animate();
        });
      }, 1000);
    });

    // Set up callback to add meteorite markers to the globe (adapted from carpark display logic)
    setAddMeteoriteMarkersToGlobe((meteoriteMarkers) => {
      console.log('üÖøÔ∏è Loading meteorites on globe...', meteoriteMarkers.length, 'meteorites found');
      
      if (!meteoriteMarkers || meteoriteMarkers.length === 0) {
        console.log('‚ö†Ô∏è No meteorite data available');
        return;
      }
      
      // Filter meteorites that have valid coordinates (like filtering carparks with location)
      const meteoritesWithLocation = meteoriteMarkers.filter(meteorite => 
        meteorite.lat && meteorite.lng && 
        !isNaN(meteorite.lat) && !isNaN(meteorite.lng)
      );
      
      if (meteoritesWithLocation.length === 0) {
        console.log('‚ö†Ô∏è No meteorite coordinates found');
        return;
      }
      
      // Show every 3rd meteorite to avoid overcrowding (like carpark filtering)
      const displayMeteorites = meteoritesWithLocation.filter((meteorite, index) => index % 3 === 0);
      console.log('Displaying', displayMeteorites.length, 'out of', meteoritesWithLocation.length, 'meteorites');
      
      // Create meteorite markers with age-based color and mass-based size
      displayMeteorites.forEach((meteorite, index) => {
        const mass = parseFloat(meteorite.mass) || 0;
        const year = parseInt(meteorite.year) || 2000; // Default to 2000 if no year
        
        // Calculate age-based color (older = darker pink)
        const currentYear = 2025;
        const age = currentYear - year;
        const maxAge = 200; // Assume meteorites range from recent to ~200 years old
        const normalizedAge = Math.min(age / maxAge, 1); // 0 (new) to 1 (old)
        
        // Pink color gradient: bright pink (new) to dark magenta (old)
        const brightness = 1 - (normalizedAge * 0.7); // 1.0 to 0.3 brightness
        const baseColor = { r: 255, g: 0, b: 255 }; // Bright magenta base
        const darkColor = {
          r: Math.floor(baseColor.r * brightness),
          g: Math.floor(baseColor.g * brightness), 
          b: Math.floor(baseColor.b * brightness)
        };
        const dotColor = `rgb(${darkColor.r}, ${darkColor.g}, ${darkColor.b})`;
        
        // Calculate mass-based size (greater mass = bigger size)
        let dotSize = 0.2; // Base size
        if (mass > 0) {
          const logMass = Math.log10(mass + 1); // Log scale for mass
          const maxLogMass = 6; // Assume max ~1,000,000g (1 ton)
          const normalizedMass = Math.min(logMass / maxLogMass, 1);
          dotSize = 0.2 + (normalizedMass * 0.4); // Size from 0.2 to 0.6
        }
        
        // Create dot geometry with mass-based size
        const dotGeometry = new THREE.SphereGeometry(dotSize, 8, 8);
        const dotMaterial = new THREE.MeshBasicMaterial({
          color: dotColor,
          transparent: true,
          opacity: 0.9
        });
        
        const meteoriteSpot = new THREE.Mesh(dotGeometry, dotMaterial);
        
        // Position on globe surface (like positioning carpark markers)
        const coords = world.getCoords(meteorite.lat, meteorite.lng, 0.001);
        const { x, y, z } = coords;
        meteoriteSpot.position.set(x, y, z);
        
        // Add to scene
        world.scene().add(meteoriteSpot);
        
        // Store meteorite reference for hover detection
        meteoriteSpheres.push({
          sphere: meteoriteSpot,
          data: meteorite
        });
        
        // Debug log every 50th meteorite with age and size info
        if (index % 50 === 0) {
          console.log(`Meteorite ${index}: ${meteorite.name || 'Unknown'} at lat=${meteorite.lat}, lng=${meteorite.lng}`);
          console.log(`  Mass: ${mass}g, Year: ${year}, Age: ${age} years, Size: ${dotSize.toFixed(3)}, Color: ${dotColor}`);
        }
      });
      
      console.log('‚úÖ Finished adding', displayMeteorites.length, 'meteorites with age-based colors (older = darker pink) and mass-based sizes (larger mass = bigger dots)');
    });

    // Set up callback to add ISS to the globe
    setAddISSToGlobe((issData) => {
      console.log('üõ∞Ô∏è ISS callback triggered with data:', issData);
      console.log('üõ∞Ô∏è Adding ISS to globe at lat:', issData.lat, 'lng:', issData.lng);
      
      // Create detailed ISS 3D model with good visibility
      const issGroup = new THREE.Group();
      
      // Main ISS body (central module) - nicely sized and visible
      const bodyGeometry = new THREE.BoxGeometry(1.5, 0.8, 1.0);
      const bodyMaterial = new THREE.MeshBasicMaterial({
        color: 0xE0E0E0, // Light silver/white
        transparent: true,
        opacity: 0.95
      });
      const issBody = new THREE.Mesh(bodyGeometry, bodyMaterial);
      issGroup.add(issBody);
      
      // Secondary modules
      const module1Geometry = new THREE.BoxGeometry(0.6, 0.4, 0.8);
      const module1Material = new THREE.MeshBasicMaterial({ color: 0xC0C0C0 });
      const module1 = new THREE.Mesh(module1Geometry, module1Material);
      module1.position.set(0, 0, 1.2);
      issGroup.add(module1);
      
      const module2 = new THREE.Mesh(module1Geometry, module1Material);
      module2.position.set(0, 0, -1.2);
      issGroup.add(module2);
      
      // Solar panel arrays
      const panelGeometry = new THREE.PlaneGeometry(3.0, 1.5);
      const panelMaterial = new THREE.MeshBasicMaterial({
        color: 0x1a1a3a, // Dark blue solar panels
        transparent: true,
        opacity: 0.9,
        side: THREE.DoubleSide
      });
      
      // Left solar panel array
      const leftPanel = new THREE.Mesh(panelGeometry, panelMaterial);
      leftPanel.position.set(-2.2, 0, 0);
      leftPanel.rotation.y = Math.PI / 2;
      issGroup.add(leftPanel);
      
      // Right solar panel array
      const rightPanel = new THREE.Mesh(panelGeometry, panelMaterial);
      rightPanel.position.set(2.2, 0, 0);
      rightPanel.rotation.y = -Math.PI / 2;
      issGroup.add(rightPanel);
      
      // Add antenna/communication arrays
      const antennaGeometry = new THREE.CylinderGeometry(0.02, 0.02, 0.3);
      const antennaMaterial = new THREE.MeshBasicMaterial({ color: 0x888888 });
      
      for (let i = 0; i < 3; i++) {
        const antenna = new THREE.Mesh(antennaGeometry, antennaMaterial);
        antenna.position.set((i - 1) * 0.2, 0.2, 0);
        antenna.rotation.z = (i - 1) * 0.2;
        issGroup.add(antenna);
      }
      
      // Add docking ports
      const dockGeometry = new THREE.CylinderGeometry(0.1, 0.1, 0.15);
      const dockMaterial = new THREE.MeshBasicMaterial({ color: 0x555555 });
      
      const dock1 = new THREE.Mesh(dockGeometry, dockMaterial);
      dock1.position.set(0, -0.2, 0.3);
      dock1.rotation.x = Math.PI / 2;
      issGroup.add(dock1);
      
      const dock2 = new THREE.Mesh(dockGeometry, dockMaterial);
      dock2.position.set(0, 0.2, -0.3);
      dock2.rotation.x = -Math.PI / 2;
      issGroup.add(dock2);
      
      // ISS position at proper orbital altitude
      const issAltitudeScaled = issData.altitude / 6371; // Proper scaling (altitude / Earth radius)
      const coords = world.getCoords(issData.lat, issData.lng, issAltitudeScaled);
      const { x, y, z } = coords;
      
      issGroup.position.set(x, y, z);
      
      // Orient ISS to face forward in its orbit direction
      const normal = new THREE.Vector3(x, y, z).normalize();
      issGroup.lookAt(0, 0, 0);
      issGroup.rotateY(Math.PI / 2);
      
      // Add ISS orbital trail visualization
      const orbitRadius = 1 + issAltitudeScaled;
      const orbitGeometry = new THREE.RingGeometry(orbitRadius - 0.005, orbitRadius + 0.005, 128);
      const orbitMaterial = new THREE.MeshBasicMaterial({
        color: 0x00AAFF,
        transparent: true,
        opacity: 0.6,
        side: THREE.DoubleSide
      });
      const orbitRing = new THREE.Mesh(orbitGeometry, orbitMaterial);
      
      // Add subtle glow effect around ISS
      const glowGeometry = new THREE.SphereGeometry(0.4, 16, 16);
      const glowMaterial = new THREE.MeshBasicMaterial({
        color: 0x88DDFF,
        transparent: true,
        opacity: 0.3,
        blending: THREE.AdditiveBlending
      });
      const issGlow = new THREE.Mesh(glowGeometry, glowMaterial);
      issGlow.position.copy(issGroup.position);
      
      // Add to scene
      world.scene().add(issGroup);
      world.scene().add(orbitRing);
      world.scene().add(issGlow);
      
      // Store ISS reference for hover detection and animation
      issObject = {
        mesh: issGroup,
        glow: issGlow,
        orbit: orbitRing,
        data: issData,
        originalLat: issData.lat,
        originalLng: issData.lng,
        altitude: issAltitudeScaled,
        isTracking: false,
        orbitAngle: 0 // Add orbit animation angle
      };
      
      // Start ISS orbital animation
      let lastUpdateTime = Date.now();
      
      const animateISS = () => {
        const currentTime = Date.now();
        const deltaTime = (currentTime - lastUpdateTime) / 1000; // Time in seconds
        lastUpdateTime = currentTime;
        
        // ISS orbital period is approximately 93 minutes = 5580 seconds
        const orbitalPeriod = 5580; // seconds for full orbit
        const angularVelocity = (2 * Math.PI) / orbitalPeriod; // radians per second
        
        // Update orbit angle
        issObject.orbitAngle += angularVelocity * deltaTime * 60; // Speed up 60x for visibility
        
        // Calculate new position along orbital path
        const orbitRadius = 1 + issObject.altitude;
        
        // Simple circular orbit (in reality ISS orbit is more complex)
        const newLat = issObject.originalLat + (Math.sin(issObject.orbitAngle) * 15); // ¬±15 degree variation
        const newLng = issObject.originalLng + (issObject.orbitAngle * 180 / Math.PI) % 360; // Longitude progression
        
        // Normalize longitude to -180 to 180 range
        const normalizedLng = ((newLng + 180) % 360) - 180;
        
        // Update ISS position
        const newCoords = world.getCoords(newLat, normalizedLng, issObject.altitude);
        issObject.mesh.position.set(newCoords.x, newCoords.y, newCoords.z);
        issObject.glow.position.copy(issObject.mesh.position);
        
        // Update stored coordinates for tracking
        issObject.data.lat = newLat;
        issObject.data.lng = normalizedLng;
        
        // Orient ISS along its orbital motion
        const normal = new THREE.Vector3(newCoords.x, newCoords.y, newCoords.z).normalize();
        issObject.mesh.lookAt(0, 0, 0);
        issObject.mesh.rotateY(Math.PI / 2);
        
        // If in tracking mode, update camera to follow ISS
        if (issObject.isTracking) {
          world.pointOfView({
            lat: newLat,
            lng: normalizedLng,
            altitude: 0.8 // Maintain good viewing distance
          }, 0); // Immediate update for smooth tracking
        }
        
        // Animate solar panel rotation (subtle effect)
        const panelRotation = (currentTime / 5000) % (Math.PI * 2); // Slow rotation
        const leftPanel = issObject.mesh.children.find(child => 
          child.geometry instanceof THREE.PlaneGeometry && child.position.x < 0
        );
        const rightPanel = issObject.mesh.children.find(child => 
          child.geometry instanceof THREE.PlaneGeometry && child.position.x > 0
        );
        
        if (leftPanel) leftPanel.rotation.z = panelRotation;
        if (rightPanel) rightPanel.rotation.z = -panelRotation;
        
        requestAnimationFrame(animateISS);
      };
      
      // Start animation
      animateISS();
      
      console.log('üõ∞Ô∏è ISS added with realistic orbital animation');
      
      // Show the toggle button now that ISS is loaded
      const toggleButton = document.getElementById('iss-toggle-button');
      if (toggleButton) {
        toggleButton.style.display = 'block';
        console.log('üõ∞Ô∏è ISS toggle button is now visible');
      }
    });

    // Set up callback to add astronaut panels to the page
    setAddAstronautPanelToPage((astronautData) => {
      console.log('üë®‚ÄçüöÄ Adding astronaut panels with data:', astronautData);
      
      const container = document.getElementById('astronaut-panels-container');
      
      if (container) {
        // Clear existing panels
        container.innerHTML = '';
        
        // Get craft icons
        const getCraftIcon = (craft) => {
          switch(craft.toUpperCase()) {
            case 'ISS': return 'üõ∞Ô∏è';
            case 'TIANGONG': return 'üöÄ';
            case 'SHENZHOU': return 'üöÄ';
            default: return 'üåå';
          }
        };
        
        // Create a panel for each spacecraft
        Object.entries(astronautData.craftGroups).forEach(([craft, astronauts]) => {
          const panel = document.createElement('div');
          panel.className = 'astronaut-panel';
          
          const craftIcon = getCraftIcon(craft);
          const astronautCount = astronauts.length;
          const peopleText = astronautCount === 1 ? 'person' : 'people';
          
          const astronautItems = astronauts.map(person => `
            <div class="astronaut-item">
              <div class="astronaut-name">${person.name}</div>
            </div>
          `).join('');
          
          panel.innerHTML = `
            <h3><span class="craft-icon">${craftIcon}</span>${craft}</h3>
            <div class="astronaut-count">${astronautCount} ${peopleText} aboard</div>
            <div class="astronaut-list">${astronautItems}</div>
          `;
          
          container.appendChild(panel);
        });
        
        // Show the container
        container.style.display = 'flex';
        
        console.log('‚úÖ Astronaut panels created and displayed');
      } else {
        console.warn('‚ö†Ô∏è Astronaut panels container not found');
      }
    });

    // Load and plot the data
    loadMeteoriteAndFireballData();

    // Create legend - size of circle = magnitude (adapted from Leaflet control)
    function createLegend() {
      const legendDiv = document.getElementById('magnitude-legend');
      
      const magnitudes = [10];
      const labels = [];

      magnitudes.forEach((mag) => {
        const size = Math.pow(mag, 1.8);
        labels.push(
          `<div style="position: absolute; top: 70px; left: 54%; transform: translateX(-50%);">
          <svg width="${size * 3}" height="${size * 3}" viewBox="0 0 ${size * 2.5} ${size * 2.5}" style="position: absolute;">
          <defs>
          <path id="textPath${mag}" d="M ${size * 1.25}, ${size * 1.25} m -${size}, 0 a ${size},${size} 0 1,1 ${size * 2},0 a ${size},${size} 0 1,1 -${size * 2},0" />
          </defs>
          <text>
          <textPath href="#textPath${mag}" startOffset="7%" text-anchor="start" style="font-size: 9px; fill: #ffffff; font-family: 'Open Sans', sans-serif; font-weight: bold;">
          Total Radiated Energy, Joules
          </textPath>
          </text>
          </svg>
          </div>
          <div style="position: absolute; bottom: 0; right: 0; width: ${size * 2}px; height: ${size * 2}px;">
          <i style="background: rgba(255, 235, 59, 0.2); border: 2px solid #ffeb3b; width: ${size * 2}px; height: ${size * 2}px; border-radius: 50%; display: inline-block; position: absolute; top: 0; left: 0;">
          </i>
          <i style="background: rgba(255, 235, 59, 0.4); border: 2px solid #ffeb3b; width: ${size * 1.5}px; height: ${size * 1.5}px; border-radius: 50%; display: inline-block; position: absolute; top: 25%; left: 25%;"></i>
          <i style="background: rgba(255, 235, 59, 0.5); border: 2px solid #ffeb3b; width: ${size}px; height: ${size}px; border-radius: 50%; display: inline-block; position: absolute; top: 50%; left: 50%;"></i>
          </div>
          <div style="position: absolute; bottom: 0px; right: 120px;"><span style="color: white;">Q<sub>e</sub></span></div>`
        );
      });

      legendDiv.innerHTML = labels.join("<br>");
    }

    // Initialize legend
    createLegend();

    // Add clouds sphere
    const CLOUDS_IMG_URL = './data/clouds.png';
    const CLOUDS_ALT = 0.004;
    const CLOUDS_ROTATION_SPEED = -0.006; // deg/frame

    new THREE.TextureLoader().load(CLOUDS_IMG_URL, cloudsTexture => {
      const clouds = new THREE.Mesh(
        new THREE.SphereGeometry(world.getGlobeRadius() * (1 + CLOUDS_ALT), 75, 75),
        new THREE.MeshPhongMaterial({ map: cloudsTexture, transparent: true })
      );
      world.scene().add(clouds);

      (function rotateClouds() {
        clouds.rotation.y += CLOUDS_ROTATION_SPEED * Math.PI / 180;
        requestAnimationFrame(rotateClouds);
      })();
    });
  </script>
</body>
</html>