<!DOCTYPE html>
<html lang="en">

<head>
  <style> body { margin: 0; } </style>

  <script src="//cdn.jsdelivr.net/npm/globe.gl"></script>
  <!--<script src="../../dist/globe.gl.js"></script>-->
</head>

<body>
  <div id="globeViz"></div>

  <script type="module">
    import * as THREE from 'https://esm.sh/three';
    import { loadMeteoriteAndFireballData, setAddFireballMarkersToGlobe, setAddMeteoriteMarkersToGlobe } from './js/globe.js';

    // Utility functions for hover display
    function formatScientificNotation(value) {
      if (!value || value === '') return 'Unknown';
      const num = parseFloat(value);
      if (isNaN(num)) return value;
      return num.toExponential(2).replace('e+', ' × 10^').replace('e-', ' × 10^-');
    }

    function formatNumber(value) {
      if (!value || value === '') return 'Unknown';
      const num = parseFloat(value);
      if (isNaN(num)) return value;
      return num.toLocaleString();
    }

    // Enhanced location lookup with multiple fallback APIs
    async function getLocationName(lat, lng) {
      // Try multiple geocoding services for better success rate
      const geocodingServices = [
        // Service 1: BigDataCloud (free, no key required)
        async () => {
          const controller = new AbortController();
          const timeoutId = setTimeout(() => controller.abort(), 5000);
          
          const response = await fetch(`https://api.bigdatacloud.net/data/reverse-geocode-client?latitude=${lat}&longitude=${lng}&localityLanguage=en`, {
            signal: controller.signal
          });
          clearTimeout(timeoutId);
          
          if (!response.ok) throw new Error(`BigDataCloud HTTP ${response.status}`);
          
          const data = await response.json();
          console.log('BigDataCloud data for', lat, lng, ':', data);
          
          if (data.city && data.countryName) {
            return `Near ${data.city}, ${data.countryName}`;
          } else if (data.locality && data.countryName) {
            return `Near ${data.locality}, ${data.countryName}`;
          } else if (data.principalSubdivision && data.countryName) {
            return `Near ${data.principalSubdivision}, ${data.countryName}`;
          } else if (data.countryName) {
            return `${data.countryName}`;
          }
          throw new Error('No usable location data from BigDataCloud');
        },
        
        // Service 2: OpenStreetMap Nominatim (free, no key required)
        async () => {
          const controller = new AbortController();
          const timeoutId = setTimeout(() => controller.abort(), 5000);
          
          const response = await fetch(`https://nominatim.openstreetmap.org/reverse?format=json&lat=${lat}&lon=${lng}&addressdetails=1&accept-language=en`, {
            signal: controller.signal,
            headers: {
              'User-Agent': 'MeteoRights/1.0 (Fireball Visualization)'
            }
          });
          clearTimeout(timeoutId);
          
          if (!response.ok) throw new Error(`Nominatim HTTP ${response.status}`);
          
          const data = await response.json();
          console.log('Nominatim data for', lat, lng, ':', data);
          
          if (data.address) {
            const addr = data.address;
            const city = addr.city || addr.town || addr.village || addr.municipality;
            const country = addr.country;
            
            if (city && country) {
              return `Near ${city}, ${country}`;
            } else if (addr.state && country) {
              return `Near ${addr.state}, ${country}`;
            } else if (country) {
              return `${country}`;
            }
          }
          throw new Error('No usable location data from Nominatim');
        },
        
        // Service 3: Geographic classifier (backup with country/ocean detection)
        async () => {
          // Skip the API call and go directly to geographic classification
          
          // Country/region boundaries (approximate)
          const countries = [
            { name: "United States", latRange: [25, 50], lngRange: [-125, -65] },
            { name: "Canada", latRange: [42, 85], lngRange: [-141, -52] },
            { name: "Mexico", latRange: [14, 33], lngRange: [-118, -86] },
            { name: "Brazil", latRange: [-34, 5], lngRange: [-74, -35] },
            { name: "Argentina", latRange: [-55, -22], lngRange: [-73, -53] },
            { name: "Russia", latRange: [41, 82], lngRange: [19, 180] },
            { name: "Russia", latRange: [64, 82], lngRange: [-180, -169] },
            { name: "China", latRange: [18, 54], lngRange: [73, 135] },
            { name: "India", latRange: [6, 37], lngRange: [68, 97] },
            { name: "Australia", latRange: [-44, -10], lngRange: [113, 154] },
            { name: "South Africa", latRange: [-35, -22], lngRange: [16, 33] },
            { name: "Algeria", latRange: [19, 37], lngRange: [-8, 12] },
            { name: "Saudi Arabia", latRange: [16, 32], lngRange: [34, 55] },
            { name: "Kazakhstan", latRange: [40, 56], lngRange: [46, 87] },
            { name: "Iran", latRange: [25, 40], lngRange: [44, 63] },
            { name: "Libya", latRange: [20, 33], lngRange: [9, 25] },
            { name: "Sudan", latRange: [8, 22], lngRange: [21, 39] },
            { name: "Chad", latRange: [7, 23], lngRange: [13, 24] },
            { name: "Niger", latRange: [11, 24], lngRange: [0, 16] },
            { name: "Angola", latRange: [-18, -4], lngRange: [11, 24] },
            { name: "Mali", latRange: [10, 25], lngRange: [-12, 4] },
            { name: "Ethiopia", latRange: [3, 18], lngRange: [33, 48] },
            { name: "Egypt", latRange: [22, 32], lngRange: [25, 37] },
            { name: "Tanzania", latRange: [-12, -1], lngRange: [29, 41] },
            { name: "Nigeria", latRange: [4, 14], lngRange: [2, 15] },
            { name: "Venezuela", latRange: [0, 12], lngRange: [-73, -60] },
            { name: "Colombia", latRange: [-4, 12], lngRange: [-79, -66] },
            { name: "Peru", latRange: [-18, 0], lngRange: [-81, -68] },
            { name: "Mongolia", latRange: [41, 52], lngRange: [87, 120] }
          ];
          
          // Check if coordinates fall within any country
          for (const country of countries) {
            if (lat >= country.latRange[0] && lat <= country.latRange[1] &&
                lng >= country.lngRange[0] && lng <= country.lngRange[1]) {
              return `Near ${country.name}`;
            }
          }
          
          // Ocean classification
          const oceans = [
            { name: "Pacific Ocean", latRange: [-60, 65], lngRange: [120, -70] }, // Crosses dateline
            { name: "Atlantic Ocean", latRange: [-60, 70], lngRange: [-70, 20] },
            { name: "Indian Ocean", latRange: [-60, 30], lngRange: [20, 120] },
            { name: "Arctic Ocean", latRange: [65, 90], lngRange: [-180, 180] },
            { name: "Southern Ocean", latRange: [-90, -60], lngRange: [-180, 180] }
          ];
          
          // Special handling for Pacific Ocean (crosses dateline)
          if (lat >= -60 && lat <= 65 && (lng >= 120 || lng <= -70)) {
            return "Pacific Ocean";
          }
          
          // Check other oceans
          for (const ocean of oceans) {
            if (ocean.name !== "Pacific Ocean" && 
                lat >= ocean.latRange[0] && lat <= ocean.latRange[1] &&
                lng >= ocean.lngRange[0] && lng <= ocean.lngRange[1]) {
              return ocean.name;
            }
          }
          
          // Default fallback
          return "Remote Location";
        }
      ];
      
      // Try each service in sequence until one succeeds
      for (let i = 0; i < geocodingServices.length; i++) {
        try {
          console.log(`Trying geocoding service ${i + 1} for`, lat, lng);
          const result = await geocodingServices[i]();
          console.log(`Service ${i + 1} succeeded:`, result);
          return result;
        } catch (error) {
          console.warn(`Geocoding service ${i + 1} failed for`, lat, lng, ':', error.message);
          
          // If this is the last service, provide a meaningful fallback
          if (i === geocodingServices.length - 1) {
            // Simple country/ocean classification based on major regions
            if (lat >= 25 && lat <= 50 && lng >= -125 && lng <= -65) {
              return "Near United States";
            } else if (lat >= 42 && lat <= 85 && lng >= -141 && lng <= -52) {
              return "Near Canada";
            } else if (lat >= 18 && lat <= 54 && lng >= 73 && lng <= 135) {
              return "Near China";
            } else if (lat >= 41 && lat <= 82 && lng >= 19 && lng <= 180) {
              return "Near Russia";
            } else if (lat >= -44 && lat <= -10 && lng >= 113 && lng <= 154) {
              return "Near Australia";
            } else if (lat >= -60 && lat <= 65 && (lng >= 120 || lng <= -70)) {
              return "Pacific Ocean";
            } else if (lat >= -60 && lat <= 70 && lng >= -70 && lng <= 20) {
              return "Atlantic Ocean";
            } else if (lat >= -60 && lat <= 30 && lng >= 20 && lng <= 120) {
              return "Indian Ocean";
            } else if (lat >= 65) {
              return "Arctic Ocean";
            } else if (lat <= -60) {
              return "Southern Ocean";
            } else {
              return "Remote Location";
            }
          }
        }
      }
    }

    // Create hover tooltip
    function createTooltip() {
      const tooltip = document.createElement('div');
      tooltip.id = 'fireball-tooltip';
      tooltip.style.cssText = `
        position: absolute;
        background: rgba(0, 0, 0, 0.9);
        color: #ffeb3b;
        padding: 12px;
        border-radius: 8px;
        font-family: Arial, sans-serif;
        font-size: 12px;
        line-height: 1.4;
        pointer-events: none;
        z-index: 1000;
        border: 1px solid #ffeb3b;
        box-shadow: 0 4px 12px rgba(255, 235, 59, 0.3);
        max-width: 300px;
        display: none;
      `;
      document.body.appendChild(tooltip);
      return tooltip;
    }

    const tooltip = createTooltip();

    const world = new Globe(document.getElementById('globeViz'), { animateIn: false })
      .globeImageUrl('//cdn.jsdelivr.net/npm/three-globe/example/img/earth-blue-marble.jpg')
      .bumpImageUrl('//cdn.jsdelivr.net/npm/three-globe/example/img/earth-topology.png');

    // Auto-rotate
    world.controls().autoRotate = true;
    world.controls().autoRotateSpeed = 0.35;

    // Raycaster for hover detection
    const raycaster = new THREE.Raycaster();
    const mouse = new THREE.Vector2();
    let fireballSpheres = []; // Store references to fireball spheres with their data
    let meteoriteSpheres = []; // Store references to meteorite spheres with their data

    // Mouse move handler for hover
    function onMouseMove(event) {
      mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
      mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;

      raycaster.setFromCamera(mouse, world.camera());
      
      // Check for fireball intersections
      const fireballIntersects = raycaster.intersectObjects(fireballSpheres.map(f => f.sphere));
      
      // Check for meteorite intersections
      const meteoriteIntersects = raycaster.intersectObjects(meteoriteSpheres.map(m => m.sphere));

      if (fireballIntersects.length > 0) {
        const intersectedFireball = fireballSpheres.find(f => f.sphere === fireballIntersects[0].object);
        if (intersectedFireball) {
          showFireballTooltip(event, intersectedFireball.data);
        }
      } else if (meteoriteIntersects.length > 0) {
        const intersectedMeteorite = meteoriteSpheres.find(m => m.sphere === meteoriteIntersects[0].object);
        if (intersectedMeteorite) {
          showMeteoriteTooltip(event, intersectedMeteorite.data);
        }
      } else {
        hideTooltip();
      }
    }

    // Show tooltip with fireball information
    async function showFireballTooltip(event, fireballData) {
      // Show tooltip immediately with coordinates, then update with location
      tooltip.innerHTML = `
        <div style="color: #ffeb3b; font-weight: bold; margin-bottom: 8px;">🔥 Fireball Event</div>
        <div><span style="color: white;">Location:</span> <span style="color: #ffeb3b;">Loading...</span></div>
        <div><span style="color: white;">Date/Time:</span> <span style="color: #ffeb3b;">${fireballData.date || 'Unknown'}</span></div>
        <div><span style="color: white;">Energy:</span> <span style="color: #ffeb3b;">${formatScientificNotation(fireballData.energy)} J</span></div>
        <div><span style="color: white;">Velocity:</span> <span style="color: #ffeb3b;">${formatNumber(fireballData.velocity)} km/s</span></div>
        <div><span style="color: white;">Altitude:</span> <span style="color: #ffeb3b;">${formatNumber(fireballData.altitude)} km</span></div>
        <div style="margin-top: 6px; font-size: 11px; color: #ccc;">
          Coordinates: ${fireballData.lat.toFixed(4)}°, ${fireballData.lng.toFixed(4)}°
        </div>
      `;
      
      tooltip.style.display = 'block';
      tooltip.style.left = (event.clientX + 10) + 'px';
      tooltip.style.top = (event.clientY - 10) + 'px';
      
      // Try to get location name and update tooltip
      try {
        const locationName = await getLocationName(fireballData.lat, fireballData.lng);
        
        // Only update if tooltip is still visible
        if (tooltip.style.display === 'block') {
          tooltip.innerHTML = `
            <div style="color: #ffeb3b; font-weight: bold; margin-bottom: 8px;">🔥 Fireball Event</div>
            <div><span style="color: white;">Location:</span> <span style="color: #ffeb3b;">${locationName}</span></div>
            <div><span style="color: white;">Date/Time:</span> <span style="color: #ffeb3b;">${fireballData.date || 'Unknown'}</span></div>
            <div><span style="color: white;">Energy:</span> <span style="color: #ffeb3b;">${formatScientificNotation(fireballData.energy)} J</span></div>
            <div><span style="color: white;">Velocity:</span> <span style="color: #ffeb3b;">${formatNumber(fireballData.velocity)} km/s</span></div>
            <div><span style="color: white;">Altitude:</span> <span style="color: #ffeb3b;">${formatNumber(fireballData.altitude)} km</span></div>
            <div style="margin-top: 6px; font-size: 11px; color: #ccc;">
              Coordinates: ${fireballData.lat.toFixed(4)}°, ${fireballData.lng.toFixed(4)}°
            </div>
          `;
        }
      } catch (error) {
        console.warn('Failed to update location in tooltip:', error);
      }
    }

    // Show tooltip with meteorite information
    async function showMeteoriteTooltip(event, meteoriteData) {
      // Show tooltip immediately with meteorite info
      const mass = parseFloat(meteoriteData.mass) || 0;
      const massDisplay = mass > 0 ? `${mass.toLocaleString()} g` : 'Unknown';
      const year = parseInt(meteoriteData.year) || null;
      const ageDisplay = year ? `${2025 - year} years old` : 'Unknown age';
      
      tooltip.innerHTML = `
        <div style="color: #FF00FF; font-weight: bold; margin-bottom: 8px;">☄️ Meteorite Landing</div>
        <div><span style="color: white;">Name:</span> <span style="color: #FF00FF;">${meteoriteData.name || 'Unknown'}</span></div>
        <div><span style="color: white;">Location:</span> <span style="color: #FF00FF;">Loading...</span></div>
        <div><span style="color: white;">Mass:</span> <span style="color: #FF00FF;">${massDisplay}</span></div>
        <div><span style="color: white;">Year Found:</span> <span style="color: #FF00FF;">${meteoriteData.year || 'Unknown'}</span></div>
        <div><span style="color: white;">Age:</span> <span style="color: #FF00FF;">${ageDisplay}</span></div>
        <div><span style="color: white;">Classification:</span> <span style="color: #FF00FF;">${meteoriteData.recclass || 'Unknown'}</span></div>
        <div style="margin-top: 6px; font-size: 11px; color: #ccc;">
          Coordinates: ${meteoriteData.lat.toFixed(4)}°, ${meteoriteData.lng.toFixed(4)}°
        </div>
      `;
      
      tooltip.style.display = 'block';
      tooltip.style.left = (event.clientX + 10) + 'px';
      tooltip.style.top = (event.clientY - 10) + 'px';
      
      // Try to get location name and update tooltip
      try {
        const locationName = await getLocationName(meteoriteData.lat, meteoriteData.lng);
        
        // Only update if tooltip is still visible
        if (tooltip.style.display === 'block') {
          tooltip.innerHTML = `
            <div style="color: #FF00FF; font-weight: bold; margin-bottom: 8px;">☄️ Meteorite Landing</div>
            <div><span style="color: white;">Name:</span> <span style="color: #FF00FF;">${meteoriteData.name || 'Unknown'}</span></div>
            <div><span style="color: white;">Location:</span> <span style="color: #FF00FF;">${locationName}</span></div>
            <div><span style="color: white;">Mass:</span> <span style="color: #FF00FF;">${massDisplay}</span></div>
            <div><span style="color: white;">Year Found:</span> <span style="color: #FF00FF;">${meteoriteData.year || 'Unknown'}</span></div>
            <div><span style="color: white;">Age:</span> <span style="color: #FF00FF;">${ageDisplay}</span></div>
            <div><span style="color: white;">Classification:</span> <span style="color: #FF00FF;">${meteoriteData.recclass || 'Unknown'}</span></div>
            <div style="margin-top: 6px; font-size: 11px; color: #ccc;">
              Coordinates: ${meteoriteData.lat.toFixed(4)}°, ${meteoriteData.lng.toFixed(4)}°
            </div>
          `;
        }
      } catch (error) {
        console.warn('Failed to update location in meteorite tooltip:', error);
      }
    }

    // Hide tooltip
    function hideTooltip() {
      tooltip.style.display = 'none';
    }

    // Add event listeners
    document.addEventListener('mousemove', onMouseMove);
    document.addEventListener('mouseleave', hideTooltip);

    // Set up callback to add fireball markers to the globe
    setAddFireballMarkersToGlobe((fireballMarkers) => {
      console.log('Adding', fireballMarkers.length, 'fireballs to globe');
      
      // Remove the problematic labels approach and use only 3D objects
      setTimeout(() => {
        // Debug: Show first few fireball coordinates and check for known locations
        console.log('First 10 fireball coordinates:');
        fireballMarkers.slice(0, 10).forEach((fb, i) => {
          console.log(`  ${i}: lat=${fb.lat}, lng=${fb.lng}, alt=${fb.altitude}km`);
          
          // Check if any are in known regions for verification
          if (fb.lat >= 6 && fb.lat <= 37 && fb.lng >= 68 && fb.lng <= 97) {
            console.log(`    ↳ This should be in India region`);
          } else if (fb.lat >= 25 && fb.lat <= 50 && fb.lng >= -125 && fb.lng <= -65) {
            console.log(`    ↳ This should be in USA region`);
          } else if (fb.lat >= 18 && fb.lat <= 54 && fb.lng >= 73 && fb.lng <= 135) {
            console.log(`    ↳ This should be in China region`);
          }
        });
        
        fireballMarkers.forEach((fb, index) => {
          console.log(`Processing fireball ${index}: lat=${fb.lat}, lng=${fb.lng}`);
          
          // Use Globe.gl's built-in coordinate conversion
          const altitudeKm = parseFloat(fb.altitude) || 0;
          console.log('Fireball position: lat', fb.lat, 'lng', fb.lng, 'alt', altitudeKm, 'km');
          
          // Much smaller altitude scaling to keep fireballs close to surface
          const scaledAltitude = altitudeKm / 1000; // Very small scaling - divide by 1000 instead of 20
          
          // Use Globe.gl's getCoords method for proper coordinate conversion
          const coords = world.getCoords(fb.lat, fb.lng, Math.max(0.01, scaledAltitude));
          const { x, y, z } = coords;
          
          console.log(`3D position for lat=${fb.lat}, lng=${fb.lng}: x=${x.toFixed(2)}, y=${y.toFixed(2)}, z=${z.toFixed(2)}`);
          
          // Create glowing sphere with same size for all fireballs
          const sphereSize = 0.6; // Fixed size regardless of altitude
          const geometry = new THREE.SphereGeometry(sphereSize, 16, 16);
          const material = new THREE.MeshBasicMaterial({
            color: 0xff6600, // All orange color
            transparent: true,
            opacity: 0.9,
            blending: THREE.AdditiveBlending // Blend with illumination
          });
          const sphere = new THREE.Mesh(geometry, material);
          sphere.position.set(x, y, z);
          
          // Create illumination circles (multiple circles for glow effect like lamp posts)
          const energy = parseFloat(fb.energy) || 0;
          console.log('Raw energy value:', fb.energy, 'Parsed:', energy);
          
          // Better normalization for scientific notation energy values
          // Energy ranges from about 1e6 J to 1e15 J based on typical fireball data
          const logEnergy = energy > 0 ? Math.log10(energy) : 6; // Default to 1e6 if no energy
          const normalizedEnergy = Math.max(0, Math.min(1, (logEnergy - 6) / 9)); // Map 1e6-1e15 to 0-1
          const energyIntensity = Math.max(0.1, normalizedEnergy); // Minimum 0.1 intensity
          
          console.log('Energy calculation:', {
            rawEnergy: energy,
            logEnergy: logEnergy,
            normalizedEnergy: normalizedEnergy,
            energyIntensity: energyIntensity
          });
          
          const baseRadius = 0.8 + (energyIntensity * 1.5); // Radius varies from 0.8 to 2.3
          const illuminationColor = 0xffff00; // Yellow illumination
          const baseIntensity = 0.4 + (energyIntensity * 0.8); // Intensity varies from 0.4 to 1.2
          
          // Main illumination circle (filled, not ring)
          const illuminationGeometry = new THREE.CircleGeometry(baseRadius, 32);
          const illuminationMaterial = new THREE.MeshBasicMaterial({
            color: illuminationColor,
            transparent: true,
            opacity: baseIntensity * 0.3, // Base illumination opacity
            side: THREE.DoubleSide,
            depthWrite: false, // Prevent z-fighting
            blending: THREE.AdditiveBlending // Better blending for overlapping
          });
          const illuminationCircle = new THREE.Mesh(illuminationGeometry, illuminationMaterial);
          
          // Position slightly offset from surface to prevent glitching
          const normal = new THREE.Vector3(x, y, z).normalize();
          const offsetDistance = 0.01; // Small offset from surface
          illuminationCircle.position.set(
            x + normal.x * offsetDistance,
            y + normal.y * offsetDistance, 
            z + normal.z * offsetDistance
          );
          illuminationCircle.lookAt(0, 0, 0); // Face the center of the globe
          
          console.log('Energy for fireball at', fb.lat, fb.lng, ':', energy, 'J (', energy.toExponential(2), '), illumination intensity:', energyIntensity, 'radius:', baseRadius.toFixed(2));
          
          // Add glow effect with multiple circles (like the lamp post code)
          const glowCircles = [];
          for (let i = 1; i <= 3; i++) {
            const glowRadius = baseRadius + (i * 0.3);
            const glowGeometry = new THREE.CircleGeometry(glowRadius, 32);
            const glowMaterial = new THREE.MeshBasicMaterial({
              color: illuminationColor,
              transparent: true,
              opacity: (baseIntensity * 0.2) / i, // Decreasing opacity for outer glow
              side: THREE.DoubleSide,
              depthWrite: false, // Prevent z-fighting
              blending: THREE.AdditiveBlending // Better blending for overlapping
            });
            const glowCircle = new THREE.Mesh(glowGeometry, glowMaterial);
            
            // Position each glow circle at slightly different distances to prevent overlap
            const glowOffset = offsetDistance + (i * 0.005);
            glowCircle.position.set(
              x + normal.x * glowOffset,
              y + normal.y * glowOffset,
              z + normal.z * glowOffset
            );
            glowCircle.lookAt(0, 0, 0); // Face the center of the globe
            glowCircles.push(glowCircle);
          }
          
          // Create orbiting light
          const orbitGeometry = new THREE.SphereGeometry(0.2, 8, 8);
          const orbitMaterial = new THREE.MeshBasicMaterial({
            color: 0xffaa44,
            transparent: true,
            opacity: 0.8
          });
          const orbitSphere = new THREE.Mesh(orbitGeometry, orbitMaterial);
          
          // Add all objects to scene (illumination circles first, then sphere)
          world.scene().add(illuminationCircle);
          glowCircles.forEach(circle => world.scene().add(circle));
          world.scene().add(sphere);
          world.scene().add(orbitSphere);

          // Store fireball reference for hover detection
          fireballSpheres.push({
            sphere: sphere,
            data: fb
          });
          
          // Animate the illumination pulsing (like Singapore lamp posts)
          let pulseTime = index * 0.5; // Offset each fireball's pulse
          let glideTime = index * 1.2; // Offset each fireball's glide animation
          
          // Calculate glide speed based on velocity from CSV data
          const velocity = parseFloat(fb.velocity) || 20; // Default 20 km/s if no velocity data
          console.log('Velocity for fireball at', fb.lat, fb.lng, ':', velocity, 'km/s');
          
          // Normalize velocity (typical range 11-72 km/s for meteors)
          const normalizedVelocity = Math.max(0.1, Math.min(1, (velocity - 11) / 61)); // Map 11-72 km/s to 0.1-1
          const velocityBasedSpeed = 0.008 + (normalizedVelocity * 0.025); // Speed varies from 0.008 to 0.033
          
          // Higher velocity = more oscillation and faster movement
          const velocityOscillation = 0.1 + (normalizedVelocity * 0.3); // Restored to the working version: 0.1 to 0.4
          const glideDuration = 12 - (normalizedVelocity * 6); // Duration from 12s (slow) to 6s (fast)
          
          console.log('Velocity calculations:', {
            velocity: velocity,
            normalizedVelocity: normalizedVelocity,
            glideSpeed: velocityBasedSpeed,
            oscillation: velocityOscillation,
            duration: glideDuration
          });
          
          // Store original position for gliding calculation
          const originalLat = fb.lat;
          const originalLng = fb.lng;
          const originalAltitude = Math.max(0.01, scaledAltitude);
          
          const animateIllumination = () => {
            pulseTime += 0.02;
            glideTime += velocityBasedSpeed; // Use velocity-based speed instead of fixed speed
            
            // Create pulsing effect like the lamp post CSS animation
            const pulseScale = 1 + 0.2 * Math.sin(pulseTime * 2); // Scale between 0.8 and 1.2
            const pulseOpacity = 0.8 + 0.4 * Math.sin(pulseTime * 2); // Opacity variation
            
            // Shooting star gliding animation
            const glideProgress = (glideTime % glideDuration) / glideDuration; // 0 to 1
            const glidePhase = glideProgress * Math.PI * 2; // Full circle
            
            // Calculate gliding position - oscillation based on velocity
            const glideLat = originalLat + (Math.sin(glidePhase) * velocityOscillation * 10); // Restored to 10x multiplier
            const glideLng = originalLng + (Math.cos(glidePhase) * velocityOscillation * 10); // Restored to 10x multiplier
            
            // Debug gliding for first fireball
            if (index === 0 && Math.floor(glideTime) % 3 === 0) {
              console.log(`Gliding debug - Fireball ${index}:`, {
                glideTime: glideTime.toFixed(2),
                glideProgress: glideProgress.toFixed(3),
                glidePhase: glidePhase.toFixed(3),
                originalLat: originalLat,
                originalLng: originalLng,
                glideLat: glideLat.toFixed(4),
                glideLng: glideLng.toFixed(4),
                latOffset: (glideLat - originalLat).toFixed(4),
                lngOffset: (glideLng - originalLng).toFixed(4),
                oscillation: velocityOscillation,
                speed: velocityBasedSpeed,
                sinValue: Math.sin(glidePhase).toFixed(4),
                cosValue: Math.cos(glidePhase).toFixed(4)
              });
            }
            
            // Use Globe.gl's coordinate conversion for gliding position
            const glideCoords = world.getCoords(glideLat, glideLng, originalAltitude);
            const { x: glideX, y: glideY, z: glideZ } = glideCoords;
            
            // Fade in/out effect for shooting star
            let starOpacity = 1;
            if (glideProgress < 0.1) {
              starOpacity = glideProgress / 0.1; // Fade in
            } else if (glideProgress > 0.9) {
              starOpacity = (1 - glideProgress) / 0.1; // Fade out
            }
            
            // Update fireball position
            sphere.position.set(glideX, glideY, glideZ);
            
            // Update illumination positions
            const glideNormal = new THREE.Vector3(glideX, glideY, glideZ).normalize();
            const offsetDistance = 0.01; // Small offset from surface
            illuminationCircle.position.set(
              glideX + glideNormal.x * offsetDistance,
              glideY + glideNormal.y * offsetDistance,
              glideZ + glideNormal.z * offsetDistance
            );
            illuminationCircle.lookAt(0, 0, 0);
            
            // Update glow circles positions
            glowCircles.forEach((circle, i) => {
              const glowOffset = offsetDistance + (i * 0.005);
              circle.position.set(
                glideX + glideNormal.x * glowOffset,
                glideY + glideNormal.y * glowOffset,
                glideZ + glideNormal.z * glowOffset
              );
              circle.lookAt(0, 0, 0);
            });
            
            // Animate the fireball sphere with pulsing and color blending
            const fireballPulse = 1 + 0.1 * Math.sin(pulseTime * 2.5); // Reduced pulse from 0.3 to 0.1
            const fireballOpacity = 0.85 + 0.15 * Math.sin(pulseTime * 2.5); // Reduced opacity variation
            
            // Blend orange with yellow based on energy and pulse
            const blendFactor = 0.3 + (energyIntensity * 0.4) + (0.1 * Math.sin(pulseTime * 3)); // Reduced color pulse
            const blendedColor = new THREE.Color(0xff6600).lerp(new THREE.Color(0xffff00), blendFactor);
            
            sphere.scale.setScalar(fireballPulse);
            sphere.material.opacity = 0.9 * fireballOpacity * starOpacity;
            sphere.material.color = blendedColor;
            
            // Apply pulsing to main illumination circle
            illuminationCircle.scale.setScalar(pulseScale);
            illuminationCircle.material.opacity = (baseIntensity * 0.3) * pulseOpacity * starOpacity;
            
            // Apply pulsing to glow circles with different phases
            glowCircles.forEach((circle, i) => {
              const phaseOffset = i * 0.5;
              const glowPulse = 1 + 0.15 * Math.sin((pulseTime + phaseOffset) * 1.5);
              const glowOpacityPulse = 0.7 + 0.3 * Math.sin((pulseTime + phaseOffset) * 1.5);
              
              circle.scale.setScalar(glowPulse);
              circle.material.opacity = ((baseIntensity * 0.2) / (i + 1)) * glowOpacityPulse * starOpacity;
            });
            
            requestAnimationFrame(animateIllumination);
          };
          
          animateIllumination();
          
          // Animate the orbiting sphere to follow the gliding fireball
          let angle = index * Math.PI / 4;
          const animate = () => {
            angle += 0.02;
            const orbitRadius = 1.5;
            
            // Get current fireball position for orbiting
            const currentFireballPos = sphere.position;
            const orbitX = currentFireballPos.x + orbitRadius * Math.cos(angle);
            const orbitZ = currentFireballPos.z + orbitRadius * Math.sin(angle);
            
            orbitSphere.position.set(orbitX, currentFireballPos.y, orbitZ);
            requestAnimationFrame(animate);
          };
          
          animate();
        });
      }, 1000);
    });

    // Set up callback to add meteorite markers to the globe (adapted from carpark display logic)
    setAddMeteoriteMarkersToGlobe((meteoriteMarkers) => {
      console.log('🅿️ Loading meteorites on globe...', meteoriteMarkers.length, 'meteorites found');
      
      if (!meteoriteMarkers || meteoriteMarkers.length === 0) {
        console.log('⚠️ No meteorite data available');
        return;
      }
      
      // Filter meteorites that have valid coordinates (like filtering carparks with location)
      const meteoritesWithLocation = meteoriteMarkers.filter(meteorite => 
        meteorite.lat && meteorite.lng && 
        !isNaN(meteorite.lat) && !isNaN(meteorite.lng)
      );
      
      if (meteoritesWithLocation.length === 0) {
        console.log('⚠️ No meteorite coordinates found');
        return;
      }
      
      // Show every 3rd meteorite to avoid overcrowding (like carpark filtering)
      const displayMeteorites = meteoritesWithLocation.filter((meteorite, index) => index % 3 === 0);
      console.log('Displaying', displayMeteorites.length, 'out of', meteoritesWithLocation.length, 'meteorites');
      
      // Create meteorite markers with age-based color and mass-based size
      displayMeteorites.forEach((meteorite, index) => {
        const mass = parseFloat(meteorite.mass) || 0;
        const year = parseInt(meteorite.year) || 2000; // Default to 2000 if no year
        
        // Calculate age-based color (older = darker pink)
        const currentYear = 2025;
        const age = currentYear - year;
        const maxAge = 200; // Assume meteorites range from recent to ~200 years old
        const normalizedAge = Math.min(age / maxAge, 1); // 0 (new) to 1 (old)
        
        // Pink color gradient: bright pink (new) to dark magenta (old)
        const brightness = 1 - (normalizedAge * 0.7); // 1.0 to 0.3 brightness
        const baseColor = { r: 255, g: 0, b: 255 }; // Bright magenta base
        const darkColor = {
          r: Math.floor(baseColor.r * brightness),
          g: Math.floor(baseColor.g * brightness), 
          b: Math.floor(baseColor.b * brightness)
        };
        const dotColor = `rgb(${darkColor.r}, ${darkColor.g}, ${darkColor.b})`;
        
        // Calculate mass-based size (greater mass = bigger size)
        let dotSize = 0.2; // Base size
        if (mass > 0) {
          const logMass = Math.log10(mass + 1); // Log scale for mass
          const maxLogMass = 6; // Assume max ~1,000,000g (1 ton)
          const normalizedMass = Math.min(logMass / maxLogMass, 1);
          dotSize = 0.2 + (normalizedMass * 0.4); // Size from 0.2 to 0.6
        }
        
        // Create dot geometry with mass-based size
        const dotGeometry = new THREE.SphereGeometry(dotSize, 8, 8);
        const dotMaterial = new THREE.MeshBasicMaterial({
          color: dotColor,
          transparent: true,
          opacity: 0.9
        });
        
        const meteoriteSpot = new THREE.Mesh(dotGeometry, dotMaterial);
        
        // Position on globe surface (like positioning carpark markers)
        const coords = world.getCoords(meteorite.lat, meteorite.lng, 0.001);
        const { x, y, z } = coords;
        meteoriteSpot.position.set(x, y, z);
        
        // Add to scene
        world.scene().add(meteoriteSpot);
        
        // Store meteorite reference for hover detection
        meteoriteSpheres.push({
          sphere: meteoriteSpot,
          data: meteorite
        });
        
        // Debug log every 50th meteorite with age and size info
        if (index % 50 === 0) {
          console.log(`Meteorite ${index}: ${meteorite.name || 'Unknown'} at lat=${meteorite.lat}, lng=${meteorite.lng}`);
          console.log(`  Mass: ${mass}g, Year: ${year}, Age: ${age} years, Size: ${dotSize.toFixed(3)}, Color: ${dotColor}`);
        }
      });
      
      console.log('✅ Finished adding', displayMeteorites.length, 'meteorites with age-based colors (older = darker pink) and mass-based sizes (larger mass = bigger dots)');
    });

    // Load and plot the data
    loadMeteoriteAndFireballData();

    // Add clouds sphere
    const CLOUDS_IMG_URL = 'data/clouds.png';
    const CLOUDS_ALT = 0.004;
    const CLOUDS_ROTATION_SPEED = -0.006; // deg/frame

    new THREE.TextureLoader().load(CLOUDS_IMG_URL, cloudsTexture => {
      const clouds = new THREE.Mesh(
        new THREE.SphereGeometry(world.getGlobeRadius() * (1 + CLOUDS_ALT), 75, 75),
        new THREE.MeshPhongMaterial({ map: cloudsTexture, transparent: true })
      );
      world.scene().add(clouds);

      (function rotateClouds() {
        clouds.rotation.y += CLOUDS_ROTATION_SPEED * Math.PI / 180;
        requestAnimationFrame(rotateClouds);
      })();
    });
  </script>
</body>
</html>